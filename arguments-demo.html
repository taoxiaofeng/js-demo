<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>arguments</title>
</head>
<body>
<script type="text/javascript">
	/**arguments是函数调用时，创建的一个类似的数组但又不是数组的对象，并且它存储的是实际传递给函数的参数，并不局限于函数声明的参数列表*/
	// function obj() {
	// 	console.log('arguments istanceof Array:' + (arguments instanceof Array));
	// 	console.log('arguments instanceof Object:' + (arguments instanceof Object));
	// 	console.log(arguments);
	// }
	// obj('monkey','love',24);

	// callee是arguments对象的一个成员，它的值为“正被执行的Function对象”。
	// function obj() {
	// 	 //利用callee
	// 	console.log(arguments.callee);
	// }
	// obj();
	// arguments.callee是指向参数arguments对象的函数，在这里就是obj.
	// function add(x){
	// 	console.log(arguments[0],arguments[1],arguments[2]);
	// 	return x + 1;
	// }
	// console.log(add(1));
	// console.log(add('1'));
	// console.log(add());
	// console.log(add(1,2));
	// console.log(add(1,2,3));
	// 　arguments对象的length属性显示实参的个数，函数的length属性显示形参的个数
	// function add(x,y){
	// 	console.log(arguments.length);
	// 	return x+1;
	// }
	// add(1,2,3);
	// console.log(add.length);
	// function add(){
	// 	return arguments[0] + arguments[1];
	// }
	// console.log(add(1,3));
// 	function arraycopy(/*array*/from,/*index*/form_start,/*array*/to,/*index*/to_start,/*integer*/length){
//     //todo
// }
// 	function easycopy(args){
// 		arraycopy(args.from,args.from_start || 0,args.to,args.to_start || 0, args.length);
// 	}
// 	var a = [1,2,3,4],b = [];
// 	console.log(easycopy({from:a,to:b,length:4}));

// function test(num1,num2){
// 	'use strict'//严格模式
// 	console.log(num1,arguments[0]);
// 	arguments[0] = 2;
// 	console.log(num1,arguments[0]);
// 	num1 = 10;
// 	console.log(num1,arguments[0])
// }
// test(1);
//不传参的情况下
// function test(num1,num2){
// 	console.log(num1,arguments[0]);
// 	arguments[0] = 2;
// 	console.log(num1,arguments[0]);
// 	num1 = 10;
// 	console.log(num1,arguments[0])
// }
// test();
//内部属性 callee
//arguments对象有一个名为callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数
// function factorial(num){
// 	if(num <= 1){
// 		return 1;
// 	}else {
// 		return num * factorial(num-1);
// 	}
// }
// console.log(factorial(5));

// //使用arguments.callee可以消除函数解耦
// function factorial(num){
// 	'use strict'
// 	if (num <= 1) {
// 		return 1;
// 	} else {
// 		return num * arguments.callee(num-1);
// 	}
// }
// console.log(factorial(5));
// //严格模式下会报错：Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
//可以使用具名的函数表达式
// var factorial = function fu(num){
// 	if(num <= 1) {
// 		return 1;
// 	} else {
// 		return num*fu(num-1); 
// 	}
// };
// console.log(factorial(5));
//函数的caller属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值是null

// function outer(){
// 	inner();
// }
// function inner() {
// 	console.log(inner.caller);
// }
// outer();
//严格模式下会报错：arguments-demo.html:114 Uncaught TypeError: 'caller' and 'arguments' are restricted function properties and cannot be accessed in this context.
// function inner(){
// 	'use strict'
// 	console.log(inner.caller);
// }
// inner();
//严格模式下报错：
// function inner(x){
// 	'use strict'
// 	console.log(arguments.caller);
// }
// inner(1);
//函数的重载
// function addSomeNumber(num) {
// 	return num + 100;
// }
// function addSomeNumber(num) {
// 	return num + 200;
// }
// var result = addSomeNumber(100);
// console.log(result);

// function doAdd() {
// 	if(arguments.length == 1){
// 		alert(arguments[0] + 10);
// 	} else if(arguments.length == 2) {
// 		alert(arguments[0] +　arguments[1])
// 	}
// }
// doAdd(10);
// doAdd(30,20);

// function addTen(num) {
// 	num += 10;
// 	return num;
// }

// var count = 20;
// var result = addTen(count);
// console.log(count);
// console.log(result)
//引用类型值
// function setName(obj){
// 	obj.name = 'text';
// }
// var person = new Object();
// setName(person);
// console.log(person.name);
function setName(obj) {
	obj.name = 'test';
	console.log(person.name);
	obj = new Object();
	obj.name = 'white';
	console.log(person.name);
}

var person = new Object();
setName(person);


</script>
	
</body>
</html>;
